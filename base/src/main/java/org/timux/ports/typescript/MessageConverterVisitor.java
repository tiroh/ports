/*
 * Copyright 2022 Tim Rohlfs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.timux.ports.typescript;

import org.timux.ports.Ports;
import org.timux.ports.Response;
import org.timux.ports.types.PairX;
import org.timux.ports.types.Tuple;
import org.timux.ports.verification.Reporter;

import javax.lang.model.element.Element;
import javax.lang.model.element.ElementVisitor;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Name;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.TypeParameterElement;
import javax.lang.model.element.VariableElement;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

class MessageConverterVisitor implements ElementVisitor<Void, Void> {

  private final String DIRECTORY = System.getProperty("user.dir") + "/frontend/generated-types";

  private final Reporter reporter;

  MessageConverterVisitor(Reporter reporter) {
    this.reporter = reporter;
  }

  @Override
  public Void visit(Element e, Void unused) {
    return null;
  }

  @Override
  public Void visit(Element e) {
    return null;
  }

  @Override
  public Void visitPackage(PackageElement e, Void unused) {
    return null;
  }

  @Override
  public Void visitType(TypeElement element, Void unused) {
    String filename = String.format("%s/%s.ts", DIRECTORY, element.getSimpleName());
    System.out.println(filename);

    String responseTsType =
        Arrays.stream(element.getAnnotationsByType(Response.class))
            .map(
                a -> {
                  String t = a.toString();
                  return t.substring(t.indexOf('(') + 1, t.length() - ".class)".length());
                })
            .collect(Collectors.joining("|"));

    try {
      File dir = new File(DIRECTORY);
      dir.mkdirs();

      File file = new File(filename);
      file.createNewFile();

      String messageType =
          element.getQualifiedName().toString()
              + (responseTsType.isEmpty() ? "" : "->" + responseTsType);

      try (FileWriter fileWriter = new FileWriter(file)) {
        fileWriter.write(
            String.format(
                "// This file was generated by Ports %s.\n// DO NOT EDIT!\n// Generated from: %s\n"
                    + "export class %s {\nstatic _MESSAGE_TYPE: string = '%s';\n_messageType: string = %s._MESSAGE_TYPE;\n",
                Ports.getVersionString(),
                element.getQualifiedName().toString(),
                element.getSimpleName().toString(),
                messageType,
                element.getSimpleName().toString()));

        List<PairX<String>> members = new ArrayList<>();

        for (Element e : element.getEnclosedElements()) {
          if (!e.getKind().isField()) {
            continue;
          }

          String tsType = getTypeScriptType(e.asType().toString());

          members.add(Tuple.ofX(e.getSimpleName().toString(), tsType));
        }

        for (PairX<String> p : members) {
          String name = p.getA();
          String tsType = p.getB();
          fileWriter.write(String.format("%s: %s;\n", name, tsType));
        }

        fileWriter.write("\nconstructor(");

        for (PairX<String> p : members) {
          String name = p.getA();
          String tsType = p.getB();
          fileWriter.write(String.format("%s: %s, ", name, tsType));
        }

        fileWriter.write(") {\n");

        for (PairX<String> p : members) {
          String name = p.getA();
          fileWriter.write(String.format("this.%s = %s;\n", name, name));
        }

        fileWriter.write("}\n}\n");
      }
    } catch (IOException e) {
      throw new RuntimeException(e);
    }

    return null;
  }

  private String getTypeScriptType(String javaType) {
    boolean isListType = javaType.startsWith("java.util.List<");
    boolean isArrayType = javaType.endsWith("[]");

    String baseType =
        isListType
            ? javaType.substring(15, javaType.length() - 1)
            : (isArrayType ? javaType.substring(0, javaType.length() - 2) : javaType);

    String tsType = null;

    switch (baseType) {
      case "byte":
      case "short":
      case "int":
      case "float":
      case "double":
      case "java.lang.Byte":
      case "java.lang.Short":
      case "java.lang.Integer":
      case "java.lang.Float":
      case "java.lang.Double":
      case "java.lang.Number":
        tsType = "number";
        break;
      case "boolean":
      case "java.lang.Boolean":
        tsType = "boolean";
        break;
      case "java.lang.String":
        tsType = "string";
        break;
      default:
        throw new UnsupportedTypeException(javaType);
    }

    if (isListType || isArrayType) {
      tsType += "[]";
    }

    return tsType;
  }

  @Override
  public Void visitVariable(VariableElement e, Void unused) {
    return null;
  }

  @Override
  public Void visitExecutable(ExecutableElement e, Void unused) {
    return null;
  }

  @Override
  public Void visitTypeParameter(TypeParameterElement e, Void unused) {
    return null;
  }

  @Override
  public Void visitUnknown(Element e, Void unused) {
    return null;
  }
}
